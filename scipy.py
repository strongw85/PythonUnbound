# -*- coding: utf-8 -*-
"""SciPy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11cFySiKNAGRigRtnmV2WemlFkFdyJe9Q
"""

import numpy as np
from scipy.optimize import minimize

# Define the function to be minimized
def objective_function(x):
    return x[0]**2 + x[1]**2

# Define the initial guess for the optimization
x0 = [2, 3]

# Perform the optimization using the minimize function
res = minimize(objective_function, x0)

# Print the results
print("Minimum found at:", res.x)
print("Function value at minimum:", res.fun)

"""In this example, we first import the minimize function from the scipy.optimize subpackage. Then, we define a simple function (objective_function) that we want to minimize. This function takes a single argument x, which is a 2-element array. The function returns the sum of the squares of the elements of x.

We then define an initial guess for the optimization, x0, which is set to [2, 3]. We pass the objective_function and x0 to the minimize function, and store the result in the variable res.

The res object contains the results of the optimization, including the location of the minimum (res.x) and the value of the function at that minimum (res.fun). In this example, the minimize function will return the minimum found at [0,0] and the function value at minimum is 0.

Note that this is a simple example and the scipy.optimize subpackage contains many other optimization algorithms and options that can be used to solve more complex problems.
"""

import scipy.integrate as spi

# Define the function to be integrated
def function_to_integrate(x):
    return np.sin(x)

# Perform the integration using the quad function
result, error = spi.quad(function_to_integrate, 0, np.pi)

# Print the results
print("Integration result:", result)
print("Estimated error:", error)

"""In this example, we first import the quad function from the scipy.integrate subpackage. Then, we define a simple function (function_to_integrate) that we want to integrate. This function takes a single argument x, which is a scalar. The function returns the sin(x) of the input.

We then pass the function_to_integrate and the integration limits (0, pi) to the quad function, and store the result in the variable result and error in variable error.

The quad function performs the numerical integration of the function, and returns the result of the integration and an estimate of the error in the result.

In this example, the quad function will return the result of the integral of sin(x) from 0 to pi which is 2 and the estimated error is 2.220446049250313e-14.

Note that this is a simple example and the scipy.integrate subpackage contains many other integration functions and options that can be used to solve more complex problems.
"""

import matplotlib.pyplot as plt
from scipy import ndimage
from PIL import Image

# Open an image file
im = Image.open('scipy.jpg')

# Convert the image to a numpy array
im_arr = np.array(im)

# Rotate the image by 45 degrees
rotated_im = ndimage.rotate(im_arr, 45)

# Display the original and rotated images
plt.figure()
plt.subplot(1,2,1)
plt.imshow(im_arr)
plt.title('Original')
plt.subplot(1,2,2)
plt.imshow(rotated_im)
plt.title('Rotated')
plt.show()

"""In this example, we first import the rotate function from the scipy.ndimage subpackage and also importing Image from PIL library, matplotlib.pyplot and numpy. Then, we open an image file using the PIL Image.open() function and convert it to a numpy array.

We then use the rotate function to rotate the image by 45 degrees, passing in the numpy array representation of the image and the angle of rotation (in degrees).

Finally, we use the matplotlib.pyplot.imshow() function to display the original and rotated images side by side.

You can see that the rotate function rotates the image by 45 degrees and the function can take different optional parameters such as reshape, output, order, mode, cval, clip, prefilter that can be used to control how the image is rotated.

Note that this is a simple example and the scipy.ndimage subpackage contains many other image processing functions and options that can be used to solve more complex problems.
"""

import scipy.stats as stats
import numpy as np

# Generate some data
data = np.random.normal(10, 2, 1000)

# Calculate the mean and standard deviation of the data
mean = np.mean(data)
std = np.std(data)

# Create a normal distribution object using the calculated mean and standard deviation
dist = stats.norm(mean, std)

# Calculate the probability density function (PDF) for a specific value
x = 9.5
pdf = dist.pdf(x)
print("PDF for x = 9.5:", pdf)

# Calculate the cumulative distribution function (CDF) for a specific value
cdf = dist.cdf(x)
print("CDF for x = 9.5:", cdf)

# Draw random samples from the distribution
samples = dist.rvs(size=10)
print("Random samples:", samples)

"""In this example, we first import the stats subpackage from scipy and numpy library. Then we generate some data using np.random.normal(10, 2, 1000) which will generate 1000 random samples from a normal distribution with mean 10 and standard deviation 2.

We then calculate the mean and standard deviation of the data using np.mean(data) and np.std(data) respectively.

We then create a normal distribution object using the calculated mean and standard deviation using stats.norm(mean, std).

We can then use this distribution object to perform various calculations. In this example, we calculate the probability density function (PDF) for a specific value x=9.5 using dist.pdf(x) and cumulative distribution function (CDF) for a specific value x=9.5 using dist.cdf(x) .

We also draw random samples from the distribution using dist.rvs(size=10).

Note that this is a simple example and the scipy.stats subpackage contains many other statistical functions and options that can be used to solve more complex problems.
"""